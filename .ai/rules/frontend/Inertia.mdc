---
description: Inertia.js v2 integration rules for Laravel and Vue
globs: ["**/*.php", "**/*.vue", "**/*.ts", "**/*.js"]
alwaysApply: false
---

# Inertia.js v2 Rules

## Version & Features
- **Inertia v2** with Laravel and Vue 3
- Use all v2 features: polling, prefetching, deferred props, infinite scrolling

## Backend (Laravel)

### Component Rendering
- Place components in `resources/js/Pages` directory
- Use `Inertia::render()` for server-side routing

```php
// ✅ Correct Inertia rendering
Route::get('/users', function () {
    return Inertia::render('Users/Index', [
        'users' => User::all()
    ]);
});
```

### Deferred Props
- Use for expensive data that can load after initial render
- Frontend should show skeleton/loading states

```php
Inertia::render('Dashboard', [
    'stats' => Inertia::defer(fn () => $this->getExpensiveStats()),
    'users' => User::paginate()
]);
```

### Infinite Scrolling
- Use merging props with `WhenVisible` on frontend
- Implement proper pagination on backend

## Frontend (Vue)

### Navigation
- Use `<Link>` component or `router.visit()` for navigation
- Never use traditional `<a>` tags for internal links

```vue
<script setup>
import { Link, router } from '@inertiajs/vue3'
</script>

<template>
  <!-- ✅ Component navigation -->
  <Link href="/dashboard">Dashboard</Link>
  
  <!-- ✅ Programmatic navigation -->
  <button @click="router.visit('/profile')">Profile</button>
</template>
```

### Form Handling
- Use `router.post()` and related methods
- Never use regular HTML forms

```vue
<script setup>
import { reactive } from 'vue'
import { router, usePage } from '@inertiajs/vue3'

const page = usePage()
const form = reactive({
  name: null,
  email: null
})

function submit() {
  router.post('/users', form)
}
</script>

<template>
  <form @submit.prevent="submit">
    <!-- form fields -->
  </form>
</template>
```

### Component Structure
- Vue components must have single root element
- Use Composition API with `<script setup>`

### v2 Features Implementation

#### Polling
```vue
<script setup>
import { router } from '@inertiajs/vue3'

// Poll every 5 seconds
setInterval(() => {
  router.reload({ only: ['notifications'] })
}, 5000)
</script>
```

#### Prefetching
```vue
<template>
  <!-- Prefetch on hover -->
  <Link href="/users" prefetch>Users</Link>
  
  <!-- Prefetch with caching -->
  <Link href="/dashboard" prefetch="mount" cache-for="30s">
    Dashboard
  </Link>
</template>
```

#### Deferred Props
```vue
<script setup>
import { usePage } from '@inertiajs/vue3'

const page = usePage()
// stats will be undefined initially, then load
const stats = computed(() => page.props.stats)
</script>

<template>
  <!-- Show skeleton while loading -->
  <div v-if="!stats" class="animate-pulse">
    <div class="h-4 bg-gray-200 rounded"></div>
  </div>
  <div v-else>
    {{ stats }}
  </div>
</template>
```

## Integration Points
- See `.ai/rules/backend/Controllers.mdc` for controller patterns
- See `.ai/rules/frontend/Vue.mdc` for Vue component rules
- See `.ai/rules/frontend/Forms.mdc` for form handling with DTOs
- See `.ai/rules/frontend/Routing.mdc` for route generation

## Common Pitfalls
- Don't use Blade views with Inertia
- Don't mix server-side and client-side routing
- Don't forget loading states for deferred props
- Don't use regular forms - use Inertia's form handling