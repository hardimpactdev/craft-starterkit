---
description: FormRequest validation and DTO patterns - comprehensive rules and patterns
globs: ["**/app/Http/Requests/**/*.php", "**/app/Data/**/*.php", "**/app/Http/Controllers/**/*.php"]
alwaysApply: true
---

# FormRequest & DTO Development Rules and Best Practices

## Core Principles

### Do's
- **Always use FormRequest classes** - For all validation, no exceptions
- **Always use DTOs** - Data Transfer Objects for type safety
- **Use spatie/laravel-data** - Leverage the package fully
- **Define validation in DTOs** - Single source of truth
- **Use collections over arrays** - Better type safety and methods

### Don'ts
- **Never use inline validation** - No validation in controllers
- **Don't use plain arrays** - Always create DTOs
- **Avoid validation attributes** - Use rules() method instead
- **Don't implement unnecessary methods** - Let traits handle logic
- **Never pass raw data** - Always use DTOs for data transfer

## FormRequest Structure

### FormRequest Do's
- **Extend FormRequest** - Laravel's base class
- **Use WithData trait** - From spatie/laravel-data
- **Implement only required methods** - authorize() and dataClass()
- **Return DTO class name** - In dataClass() method
- **Keep FormRequests simple** - Delegate to DTOs

```php
// ✅ Correct FormRequest structure
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;
use Spatie\LaravelData\WithData;
use App\Data\UserData;

class StoreUserRequest extends FormRequest
{
    use WithData;
    
    public function authorize(): bool
    {
        return $this->user()->can('create-users');
    }
    
    protected function dataClass(): string
    {
        return UserData::class;
    }
}

// ✅ Update request with authorization logic
class UpdateProjectRequest extends FormRequest
{
    use WithData;
    
    public function authorize(): bool
    {
        return $this->user()->can('update', $this->route('project'));
    }
    
    protected function dataClass(): string
    {
        return UpdateProjectData::class;
    }
}

// ✅ Public form request (no auth needed)
class ContactFormRequest extends FormRequest
{
    use WithData;
    
    public function authorize(): bool
    {
        return true; // Public endpoint
    }
    
    protected function dataClass(): string
    {
        return ContactData::class;
    }
}
```

### FormRequest Don'ts
```php
// ❌ Never implement rules() method
class BadRequest extends FormRequest
{
    public function rules(): array
    {
        return [
            'name' => 'required|string',
            'email' => 'required|email'
        ];
    }
}

// ❌ Don't implement messages() method
public function messages(): array
{
    return [
        'name.required' => 'Name is required'
    ];
}

// ❌ Don't implement toData() method
public function toData(): UserData
{
    return UserData::from($this->validated());
}

// ❌ Don't use inline validation in controller
public function store(Request $request)
{
    $validated = $request->validate([
        'name' => 'required'
    ]);
}

// ❌ Don't forget WithData trait
class MissingTraitRequest extends FormRequest
{
    // Missing: use WithData;
}
```

## DTO Structure and Validation

### DTO Structure Do's
- **Extend Data class** - From spatie/laravel-data
- **Define properties with types** - Use PHP types
- **Implement rules() method** - All validation here
- **Use Laravel validation rules** - Standard syntax
- **Create factory methods** - empty(), from(), etc.

```php
// ✅ Well-structured DTO
<?php

namespace App\Data;

use Spatie\LaravelData\Data;
use Spatie\LaravelData\Attributes\Computed;
use Illuminate\Support\Collection;

class UserData extends Data
{
    public function __construct(
        public ?int $id,
        public string $name,
        public string $email,
        public ?string $phone,
        public UserRole $role,
        public bool $is_active = true,
        public ?Collection $permissions = null,
        #[Computed]
        public ?string $display_name = null,
    ) {
        $this->permissions ??= collect();
        $this->display_name = "{$this->name} ({$this->email})";
    }
    
    public static function rules(): array
    {
        return [
            'name' => ['required', 'string', 'max:255'],
            'email' => ['required', 'email', 'unique:users,email'],
            'phone' => ['nullable', 'string', 'regex:/^[0-9+\-\s]+$/'],
            'role' => ['required', 'string', 'in:admin,user,guest'],
            'is_active' => ['boolean'],
            'permissions' => ['nullable', 'array'],
            'permissions.*' => ['string', 'exists:permissions,name'],
        ];
    }
    
    public static function messages(): array
    {
        return [
            'email.unique' => 'This email is already registered.',
            'phone.regex' => 'Please enter a valid phone number.',
            'role.in' => 'Please select a valid role.',
        ];
    }
    
    public static function empty(): self
    {
        return new self(
            id: null,
            name: '',
            email: '',
            phone: null,
            role: UserRole::USER,
            is_active: true,
        );
    }
}
```

### DTO Structure Don'ts
```php
// ❌ Don't use validation attributes
class BadData extends Data
{
    public function __construct(
        #[Required, Email] // Don't use these
        public string $email,
    ) {}
}

// ❌ Don't forget types
class UntypedData extends Data
{
    public function __construct(
        public $name, // Missing type
        public $email, // Missing type
    ) {}
}

// ❌ Don't use arrays instead of DTOs
class OrderData extends Data
{
    public function __construct(
        public array $items, // Should be Collection<OrderItemData>
    ) {}
}

// ❌ Don't mix validation locations
class MixedValidation extends Data
{
    #[Required] // Some here
    public string $name;
    
    public static function rules(): array
    {
        return [
            'email' => 'required' // Some here - inconsistent
        ];
    }
}
```

## Collections and Arrays

### Collections Do's
- **Use Illuminate\Support\Collection** - Not arrays
- **Type collections properly** - Specify content type
- **Use DataCollection for DTOs** - Spatie's collection type
- **Initialize collections** - In constructor or default
- **Leverage collection methods** - map, filter, etc.

```php
// ✅ Proper collection usage
use Illuminate\Support\Collection;
use Spatie\LaravelData\DataCollection;

class ProjectData extends Data
{
    public function __construct(
        public string $name,
        public Collection $tags,
        public DataCollection $tasks, // For TaskData items
        public ?Collection $metadata = null,
    ) {
        $this->metadata ??= collect();
    }
    
    public static function rules(): array
    {
        return [
            'name' => ['required', 'string'],
            'tags' => ['required', 'array', 'min:1'],
            'tags.*' => ['string', 'max:50'],
            'tasks' => ['required', 'array'],
            'tasks.*.title' => ['required', 'string'],
            'tasks.*.completed' => ['boolean'],
        ];
    }
}

// ✅ Creating DTOs with collections
$project = ProjectData::from([
    'name' => 'My Project',
    'tags' => collect(['php', 'laravel']),
    'tasks' => TaskData::collection([
        ['title' => 'Task 1', 'completed' => false],
        ['title' => 'Task 2', 'completed' => true],
    ]),
]);

// ✅ Processing collections in DTOs
class ReportData extends Data
{
    public function __construct(
        public DataCollection $entries,
    ) {}
    
    #[Computed]
    public function total(): float
    {
        return $this->entries->sum('amount');
    }
    
    #[Computed]
    public function average(): float
    {
        return $this->entries->avg('amount');
    }
}
```

### Collections Don'ts
```php
// ❌ Don't use plain arrays
class BadData extends Data
{
    public function __construct(
        public array $items, // Use Collection
        public array $users, // Use DataCollection
    ) {}
}

// ❌ Don't forget to initialize collections
class UninitializedData extends Data
{
    public function __construct(
        public Collection $items, // Could be null
    ) {
        // Missing: $this->items ??= collect();
    }
}

// ❌ Don't use wrong collection type
use Doctrine\Common\Collections\ArrayCollection; // Wrong
use Illuminate\Support\Collection; // Correct

// ❌ Don't type collections incorrectly
/** @var Collection<UserData> */ // PHPDoc only
public Collection $users; // Missing generic in property
```

## Form Data Handling

### Form Handling Do's
- **Create specific DTOs** - For each form type
- **Pass DTOs to views** - As form prop
- **Use empty() method** - For new forms
- **Use from() for editing** - Populate with existing data
- **Maintain consistency** - Frontend and backend DTOs match

```php
// ✅ Controller passing form DTO
class UserController extends Controller
{
    public function create()
    {
        return Inertia::render('Users/Create', [
            'form' => CreateUserData::empty(),
            'roles' => RoleData::collection(Role::all()),
        ]);
    }
    
    public function edit(User $user)
    {
        return Inertia::render('Users/Edit', [
            'form' => UpdateUserData::from($user),
            'roles' => RoleData::collection(Role::all()),
        ]);
    }
    
    public function store(StoreUserRequest $request)
    {
        $data = $request->getData(); // Returns CreateUserData
        
        $user = User::create($data->toArray());
        
        return redirect()->route('users.show', $user)
            ->with('success', 'User created successfully');
    }
}

// ✅ Separate DTOs for create/update
class CreateUserData extends Data
{
    public function __construct(
        public string $name,
        public string $email,
        public string $password,
        public string $password_confirmation,
    ) {}
    
    public static function rules(): array
    {
        return [
            'name' => ['required', 'string', 'max:255'],
            'email' => ['required', 'email', 'unique:users'],
            'password' => ['required', 'string', 'min:8', 'confirmed'],
        ];
    }
}

class UpdateUserData extends Data
{
    public function __construct(
        public string $name,
        public string $email,
        public ?string $password = null,
    ) {}
    
    public static function rules(): array
    {
        return [
            'name' => ['required', 'string', 'max:255'],
            'email' => ['required', 'email', 'unique:users,email,{id}'],
            'password' => ['nullable', 'string', 'min:8', 'confirmed'],
        ];
    }
}
```

### Form Handling Don'ts
```php
// ❌ Don't pass raw arrays to views
return Inertia::render('Users/Create', [
    'form' => [
        'name' => '',
        'email' => '',
    ],
]);

// ❌ Don't create forms without DTOs
return Inertia::render('Users/Create', [
    'form' => new stdClass(), // Use DTO
]);

// ❌ Don't mix form data with other props
return Inertia::render('Users/Edit', [
    'user' => $user, // Should be 'form' => UserData::from($user)
    'name' => $user->name,
    'email' => $user->email,
]);

// ❌ Don't forget empty() method
class MissingEmptyData extends Data
{
    // No empty() method defined
}
```

## Advanced DTO Patterns

### Advanced Patterns Do's
- **Use casts** - For complex transformations
- **Use computed properties** - For derived values
- **Create nested DTOs** - For complex structures
- **Use lazy properties** - For expensive computations
- **Implement custom rules** - For complex validation

```php
// ✅ Advanced DTO with casts and computed
use Spatie\LaravelData\Casts\DateTimeInterfaceCast;
use Spatie\LaravelData\Attributes\WithCast;
use Spatie\LaravelData\Attributes\Computed;
use Spatie\LaravelData\Lazy;

class OrderData extends Data
{
    public function __construct(
        public int $id,
        public string $number,
        #[WithCast(DateTimeInterfaceCast::class)]
        public DateTime $created_at,
        public DataCollection $items,
        public CustomerData $customer,
        #[Computed]
        public Lazy|float $total,
        #[Computed]
        public Lazy|string $status_label,
    ) {
        $this->total = Lazy::create(fn() => $this->calculateTotal());
        $this->status_label = Lazy::create(fn() => $this->getStatusLabel());
    }
    
    private function calculateTotal(): float
    {
        return $this->items->sum(fn(OrderItemData $item) => 
            $item->quantity * $item->price
        );
    }
    
    private function getStatusLabel(): string
    {
        return match($this->status) {
            'pending' => 'Awaiting Payment',
            'paid' => 'Payment Received',
            'shipped' => 'In Transit',
            'delivered' => 'Completed',
            default => 'Unknown',
        };
    }
    
    public static function rules(): array
    {
        return [
            'items' => ['required', 'array', 'min:1'],
            'items.*.product_id' => ['required', 'exists:products,id'],
            'items.*.quantity' => ['required', 'integer', 'min:1'],
            'customer.email' => ['required', 'email'],
            'customer.shipping_address' => ['required'],
        ];
    }
}

// ✅ Custom validation rules
class RegistrationData extends Data
{
    public function __construct(
        public string $username,
        public string $email,
        public string $password,
        public bool $agree_terms,
    ) {}
    
    public static function rules(): array
    {
        return [
            'username' => [
                'required',
                'string',
                'min:3',
                'max:20',
                'regex:/^[a-zA-Z0-9_]+$/',
                'unique:users,username',
            ],
            'email' => ['required', 'email', 'unique:users,email'],
            'password' => ['required', 'string', Password::defaults()],
            'agree_terms' => ['required', 'accepted'],
        ];
    }
    
    public static function authorize(): bool
    {
        // Can add DTO-level authorization
        return request()->ip() !== '0.0.0.0';
    }
}
```

### Advanced Patterns Don'ts
```php
// ❌ Don't calculate in constructor
public function __construct(
    public float $total, // Should be computed
) {
    $this->total = $this->items->sum('price'); // Wrong place
}

// ❌ Don't use magic methods incorrectly
public function __get($key)
{
    // Don't override magic methods
}

// ❌ Don't forget lazy loading for expensive operations
#[Computed]
public function expensive_calculation(): float
{
    // Should use Lazy for performance
    return $this->processMillionRecords();
}
```

## Testing DTOs and FormRequests

### Testing Do's
- **Test validation rules** - Ensure they work correctly
- **Test DTO transformations** - From and to array
- **Test computed properties** - Verify calculations
- **Test authorization** - FormRequest authorize method

```php
// ✅ Testing DTOs
public function test_user_data_validation()
{
    $this->expectException(ValidationException::class);
    
    UserData::validate([
        'name' => '', // Required
        'email' => 'invalid-email',
    ]);
}

public function test_dto_transformation()
{
    $user = User::factory()->create();
    $data = UserData::from($user);
    
    $this->assertEquals($user->name, $data->name);
    $this->assertEquals($user->email, $data->email);
}

// ✅ Testing FormRequests
public function test_store_user_request_authorization()
{
    $user = User::factory()->create(['role' => 'admin']);
    
    $request = new StoreUserRequest();
    $request->setUserResolver(fn() => $user);
    
    $this->assertTrue($request->authorize());
}
```

## Common Pitfalls to Avoid

1. **Using inline validation** - Always use FormRequest classes
2. **Implementing rules() in FormRequest** - Put in DTO instead
3. **Using plain arrays** - Always use Collections or DTOs
4. **Forgetting WithData trait** - Required for FormRequests
5. **Using validation attributes** - Use rules() method
6. **Not typing properties** - Always use PHP types
7. **Missing empty() method** - Required for forms
8. **Hardcoding validation messages** - Use messages() method
9. **Not using DataCollection** - For collections of DTOs
10. **Mixing validation locations** - Keep all rules in DTO