---
description: Laravel controller patterns and best practices with Inertia - comprehensive rules
globs: ["**/app/Http/Controllers/**/*.php"]
alwaysApply: true
---

# Laravel Controllers Development Rules and Best Practices

## Core Principles

### Do's
- **Use resourceful controllers** - Follow REST conventions
- **Keep controllers thin** - Business logic in services/actions
- **Always use FormRequests** - Never inline validation
- **Return proper response types** - Inertia or Redirect
- **Use dependency injection** - For services and repositories

### Don'ts
- **Never validate inline** - Use FormRequest classes
- **Don't put business logic** - Keep in services/models
- **Avoid fat controllers** - Single responsibility
- **Don't query directly** - Use repositories/services
- **Never return arrays** - Use DTOs for data

## Resourceful Controllers

### Resource Methods Do's
- **Implement only needed methods** - Not all 7 required
- **Follow naming conventions** - index, show, create, etc.
- **Use route model binding** - Automatic resolution
- **Return correct types** - Response vs RedirectResponse
- **Group related logic** - In single controller

```php
// ✅ Complete resourceful controller
<?php

namespace App\Http\Controllers;

use App\Models\Project;
use App\Data\ProjectData;
use App\Http\Requests\StoreProjectRequest;
use App\Http\Requests\UpdateProjectRequest;
use Illuminate\Http\RedirectResponse;
use Inertia\Inertia;
use Inertia\Response;

class ProjectController extends Controller
{
    protected static string $routePrefix = 'projects';
    
    #[Get]
    public function index(): Response
    {
        return Inertia::render('Projects/Index', [
            'projects' => ProjectData::collection(
                Project::with('owner')->latest()->paginate(15)
            ),
        ]);
    }
    
    #[Get(parameters: ['project'])]
    public function show(Project $project): Response
    {
        $project->load(['tasks', 'members', 'owner']);
        
        return Inertia::render('Projects/Show', [
            'project' => ProjectData::from($project),
        ]);
    }
    
    #[Get]
    public function create(): Response
    {
        return Inertia::render('Projects/Create', [
            'form' => CreateProjectData::empty(),
            'users' => UserData::collection(User::all()),
        ]);
    }
    
    #[Post]
    public function store(StoreProjectRequest $request): RedirectResponse
    {
        $data = $request->getData();
        
        $project = Project::create([
            'name' => $data->name,
            'description' => $data->description,
            'owner_id' => auth()->id(),
            'settings' => $data->settings,
        ]);
        
        return redirect()
            ->route('projects.show', $project)
            ->with('success', 'Project created successfully.');
    }
    
    #[Get(parameters: ['project'])]
    public function edit(Project $project): Response
    {
        $this->authorize('update', $project);
        
        return Inertia::render('Projects/Edit', [
            'form' => UpdateProjectData::from($project),
            'users' => UserData::collection(User::all()),
        ]);
    }
    
    #[Patch(parameters: ['project'])]
    public function update(UpdateProjectRequest $request, Project $project): RedirectResponse
    {
        $this->authorize('update', $project);
        
        $data = $request->getData();
        
        $project->update([
            'name' => $data->name,
            'description' => $data->description,
            'settings' => $data->settings,
        ]);
        
        return redirect()
            ->route('projects.show', $project)
            ->with('success', 'Project updated successfully.');
    }
    
    #[Delete(parameters: ['project'])]
    public function destroy(Project $project): RedirectResponse
    {
        $this->authorize('delete', $project);
        
        $project->delete();
        
        return redirect()
            ->route('projects.index')
            ->with('success', 'Project deleted successfully.');
    }
}

// ✅ Partial resourceful controller
class ReadOnlyResourceController extends Controller
{
    protected static string $routePrefix = 'articles';
    
    #[Get]
    public function index(): Response
    {
        return Inertia::render('Articles/Index', [
            'articles' => ArticleData::collection(Article::published()->get()),
        ]);
    }
    
    #[Get(parameters: ['article:slug'])]
    public function show(Article $article): Response
    {
        return Inertia::render('Articles/Show', [
            'article' => ArticleData::from($article),
        ]);
    }
}
```

### Resource Methods Don'ts
```php
// ❌ Don't use non-standard method names
public function list() // Should be index()
public function display($id) // Should be show()
public function add() // Should be create()
public function save() // Should be store()

// ❌ Don't mix resource and custom methods
class ProjectController extends Controller
{
    public function index() {}
    public function show() {}
    public function archive() {} // Should be separate controller
    public function duplicate() {} // Should be separate controller
}

// ❌ Don't return wrong types
#[Get]
public function index(): RedirectResponse // Should return Response
{
    return redirect()->route('home');
}

#[Post]
public function store(): Response // Should return RedirectResponse
{
    return Inertia::render('Projects/Show');
}

// ❌ Don't forget authorization
public function edit(Project $project): Response
{
    // Missing $this->authorize('update', $project);
    return Inertia::render('Projects/Edit');
}
```

## Validation with FormRequests

### FormRequest Integration Do's
- **Always use FormRequest** - See FormRequests.mdc
- **Type-hint request classes** - For auto-validation
- **Use getData() method** - Returns typed DTO
- **Handle validation errors** - Automatic with Inertia
- **Separate create/update** - Different validation rules

```php
// ✅ Using FormRequest correctly
use App\Http\Requests\StoreProjectRequest;
use App\Http\Requests\UpdateProjectRequest;

class ProjectController extends Controller
{
    #[Post]
    public function store(StoreProjectRequest $request): RedirectResponse
    {
        // Validation happens automatically
        $data = $request->getData(); // Returns CreateProjectData
        
        $project = Project::create([
            'name' => $data->name,
            'description' => $data->description,
            'budget' => $data->budget,
        ]);
        
        return redirect()->route('projects.show', $project);
    }
    
    #[Patch(parameters: ['project'])]
    public function update(UpdateProjectRequest $request, Project $project): RedirectResponse
    {
        $data = $request->getData(); // Returns UpdateProjectData
        
        $project->update($data->toArray());
        
        return back()->with('success', 'Updated successfully');
    }
}

// ✅ Complex validation scenarios
class RegistrationController extends Controller
{
    #[Post]
    public function register(RegistrationRequest $request): RedirectResponse
    {
        $data = $request->getData(); // Returns RegistrationData
        
        DB::transaction(function () use ($data) {
            $user = User::create([
                'name' => $data->name,
                'email' => $data->email,
                'password' => bcrypt($data->password),
            ]);
            
            $user->profile()->create([
                'phone' => $data->profile->phone,
                'address' => $data->profile->address,
            ]);
        });
        
        return redirect()->route('dashboard');
    }
}
```

### FormRequest Integration Don'ts
```php
// ❌ Never validate inline
public function store(Request $request)
{
    $validated = $request->validate([
        'name' => 'required|string',
        'email' => 'required|email',
    ]); // Use FormRequest instead
}

// ❌ Don't use Request directly
public function update(Request $request, Project $project)
{
    // Should use UpdateProjectRequest
}

// ❌ Don't access request data directly
public function store(StoreProjectRequest $request)
{
    $name = $request->input('name'); // Use getData()
    $data = $request->all(); // Use getData()
    $validated = $request->validated(); // Use getData()
}

// ❌ Don't forget request class
public function store(): RedirectResponse
{
    $data = request()->all(); // Missing FormRequest
}
```

## Inertia Responses

### Inertia Response Do's
- **Use Inertia::render()** - For all views
- **Pass DTOs as props** - Not arrays or models
- **Follow naming conventions** - Match controller/method
- **Include required data** - For page functionality
- **Use lazy evaluation** - For expensive data

```php
// ✅ Proper Inertia responses
use Inertia\Inertia;
use Inertia\Response;

class ProjectController extends Controller
{
    #[Get]
    public function index(): Response
    {
        return Inertia::render('Projects/Index', [
            'projects' => ProjectData::collection(
                Project::with('owner')
                    ->where('user_id', auth()->id())
                    ->latest()
                    ->paginate(15)
            ),
            'filters' => [
                'search' => request('search'),
                'status' => request('status'),
            ],
        ]);
    }
    
    #[Get(parameters: ['project'])]
    public function show(Project $project): Response
    {
        return Inertia::render('Projects/Show', [
            'project' => ProjectData::from($project)->include('tasks'),
            'permissions' => [
                'can_edit' => auth()->user()->can('update', $project),
                'can_delete' => auth()->user()->can('delete', $project),
            ],
        ]);
    }
}

// ✅ Lazy loading expensive data
#[Get]
public function dashboard(): Response
{
    return Inertia::render('Dashboard', [
        'stats' => fn() => DashboardStatsData::from([
            'total_projects' => Project::count(),
            'active_tasks' => Task::active()->count(),
            'recent_activities' => Activity::recent()->limit(10)->get(),
        ]),
        'projects' => fn() => ProjectData::collection(
            Project::latest()->limit(5)->get()
        ),
    ]);
}

// ✅ Complex page with multiple datasets
#[Get]
public function create(): Response
{
    return Inertia::render('Projects/Create', [
        'form' => CreateProjectData::empty(),
        'templates' => TemplateData::collection(Template::active()->get()),
        'categories' => CategoryData::collection(Category::all()),
        'users' => UserData::collection(User::canBeAssigned()->get()),
        'settings' => [
            'max_budget' => config('projects.max_budget'),
            'currencies' => config('projects.currencies'),
        ],
    ]);
}
```

### Inertia Response Don'ts
```php
// ❌ Don't return blade views
public function index()
{
    return view('projects.index'); // Use Inertia::render
}

// ❌ Don't pass models directly
return Inertia::render('Projects/Show', [
    'project' => $project, // Use ProjectData::from($project)
]);

// ❌ Don't pass arrays
return Inertia::render('Projects/Index', [
    'projects' => Project::all()->toArray(), // Use DataCollection
]);

// ❌ Don't forget Response type hint
public function index() // Missing : Response
{
    return Inertia::render('Projects/Index');
}

// ❌ Don't use wrong component paths
return Inertia::render('projects/index'); // Should be Projects/Index
```

## Redirect Responses

### Redirect Response Do's
- **Use route names** - Not URLs
- **Include flash messages** - User feedback
- **Redirect appropriately** - Based on action
- **Use back() sparingly** - Only when appropriate
- **Type hint returns** - RedirectResponse

```php
// ✅ Proper redirect responses
use Illuminate\Http\RedirectResponse;

class ProjectController extends Controller
{
    #[Post]
    public function store(StoreProjectRequest $request): RedirectResponse
    {
        $project = Project::create($request->getData()->toArray());
        
        return redirect()
            ->route('projects.show', $project)
            ->with('success', 'Project created successfully!');
    }
    
    #[Patch(parameters: ['project'])]
    public function update(UpdateProjectRequest $request, Project $project): RedirectResponse
    {
        $project->update($request->getData()->toArray());
        
        return redirect()
            ->route('projects.show', $project)
            ->with('success', 'Project updated successfully!');
    }
    
    #[Delete(parameters: ['project'])]
    public function destroy(Project $project): RedirectResponse
    {
        $projectName = $project->name;
        $project->delete();
        
        return redirect()
            ->route('projects.index')
            ->with('success', "Project '{$projectName}' deleted successfully!");
    }
}

// ✅ Conditional redirects
#[Post]
public function process(ProcessRequest $request): RedirectResponse
{
    $result = $this->processService->handle($request->getData());
    
    if ($result->successful) {
        return redirect()
            ->route('dashboard')
            ->with('success', 'Process completed successfully!');
    }
    
    return back()
        ->withErrors(['process' => $result->error])
        ->withInput();
}

// ✅ Redirect with multiple flash data
return redirect()
    ->route('projects.index')
    ->with([
        'success' => 'Operation completed!',
        'stats' => ['created' => 5, 'updated' => 3],
    ]);
```

### Redirect Response Don'ts
```php
// ❌ Don't use URLs directly
return redirect('/projects'); // Use route()

// ❌ Don't forget flash messages
return redirect()->route('projects.index'); // No user feedback

// ❌ Don't return Response for mutations
#[Post]
public function store(): Response // Should be RedirectResponse
{
    return Inertia::render('Projects/Show');
}

// ❌ Don't use back() after delete
public function destroy(Project $project)
{
    $project->delete();
    return back(); // Page doesn't exist anymore
}

// ❌ Don't forget type hints
public function update() // Missing : RedirectResponse
{
    return redirect()->route('projects.index');
}
```

## Authorization

### Authorization Do's
- **Use policies** - For model authorization
- **Authorize early** - Before processing
- **Use gates** - For non-model permissions
- **Pass to frontend** - For UI control
- **Handle unauthorized** - Gracefully

```php
// ✅ Using policies
class ProjectController extends Controller
{
    #[Get(parameters: ['project'])]
    public function show(Project $project): Response
    {
        $this->authorize('view', $project);
        
        return Inertia::render('Projects/Show', [
            'project' => ProjectData::from($project),
        ]);
    }
    
    #[Get(parameters: ['project'])]
    public function edit(Project $project): Response
    {
        $this->authorize('update', $project);
        
        return Inertia::render('Projects/Edit', [
            'form' => UpdateProjectData::from($project),
        ]);
    }
    
    #[Delete(parameters: ['project'])]
    public function destroy(Project $project): RedirectResponse
    {
        $this->authorize('delete', $project);
        
        $project->delete();
        
        return redirect()->route('projects.index');
    }
}

// ✅ Passing permissions to frontend
#[Get]
public function index(): Response
{
    $projects = Project::with('owner')->paginate();
    
    return Inertia::render('Projects/Index', [
        'projects' => ProjectData::collection($projects),
        'can' => [
            'create_project' => auth()->user()->can('create', Project::class),
        ],
    ]);
}

// ✅ Using gates
class AdminController extends Controller
{
    #[Get]
    public function dashboard(): Response
    {
        $this->authorize('access-admin-dashboard');
        
        return Inertia::render('Admin/Dashboard', [
            'stats' => AdminStatsData::from($this->statsService->get()),
        ]);
    }
}

// ✅ Resource authorization
public function __construct()
{
    $this->authorizeResource(Project::class, 'project');
}
```

### Authorization Don'ts
```php
// ❌ Don't forget authorization
public function edit(Project $project): Response
{
    // Missing authorization check
    return Inertia::render('Projects/Edit');
}

// ❌ Don't authorize after changes
public function update(UpdateProjectRequest $request, Project $project)
{
    $project->update($request->getData()->toArray());
    $this->authorize('update', $project); // Too late!
}

// ❌ Don't use manual checks
public function show(Project $project)
{
    if ($project->user_id !== auth()->id()) { // Use policies
        abort(403);
    }
}

// ❌ Don't expose unauthorized data
return Inertia::render('Projects/Index', [
    'projects' => Project::all(), // Should filter by authorization
]);
```

## Dependency Injection

### Dependency Injection Do's
- **Inject services** - Via constructor or methods
- **Use interfaces** - For flexibility
- **Type hint dependencies** - For clarity
- **Keep it minimal** - Only what's needed
- **Use service providers** - For binding

```php
// ✅ Constructor injection
class ProjectController extends Controller
{
    public function __construct(
        private readonly ProjectService $projectService,
        private readonly NotificationService $notificationService,
    ) {}
    
    #[Post]
    public function store(StoreProjectRequest $request): RedirectResponse
    {
        $project = $this->projectService->create(
            $request->getData(),
            auth()->user()
        );
        
        $this->notificationService->projectCreated($project);
        
        return redirect()->route('projects.show', $project);
    }
}

// ✅ Method injection
#[Post(parameters: ['project'])]
public function duplicate(
    Project $project,
    ProjectDuplicationService $duplicationService
): RedirectResponse {
    $this->authorize('duplicate', $project);
    
    $newProject = $duplicationService->duplicate($project);
    
    return redirect()
        ->route('projects.show', $newProject)
        ->with('success', 'Project duplicated successfully!');
}

// ✅ Interface injection
class ExportController extends Controller
{
    public function __construct(
        private readonly ExportServiceInterface $exportService,
    ) {}
    
    #[Get(parameters: ['project'])]
    public function export(Project $project, string $format): Response
    {
        $export = $this->exportService->export($project, $format);
        
        return response()->download($export->path);
    }
}
```

### Dependency Injection Don'ts
```php
// ❌ Don't create instances manually
public function index()
{
    $service = new ProjectService(); // Use DI
    $projects = $service->getAll();
}

// ❌ Don't use facades in controllers
public function store()
{
    Cache::put('key', 'value'); // Inject cache service
    Log::info('Stored'); // Inject logger
}

// ❌ Don't inject too many dependencies
public function __construct(
    private Service1 $service1,
    private Service2 $service2,
    private Service3 $service3,
    private Service4 $service4,
    private Service5 $service5, // Too many!
) {}

// ❌ Don't use service locator pattern
public function index()
{
    $service = app(ProjectService::class); // Use constructor DI
}
```

## Private Methods

### Private Methods Do's
- **Extract complex logic** - Into private methods
- **Keep them focused** - Single responsibility
- **Name them clearly** - Describe what they do
- **Reuse common logic** - DRY principle
- **Test indirectly** - Through public methods

```php
// ✅ Well-organized private methods
class ProjectController extends Controller
{
    #[Get]
    public function index(): Response
    {
        $projects = $this->getUserProjects();
        $stats = $this->calculateProjectStats($projects);
        
        return Inertia::render('Projects/Index', [
            'projects' => ProjectData::collection($projects),
            'stats' => $stats,
        ]);
    }
    
    private function getUserProjects(): Collection
    {
        return auth()->user()
            ->projects()
            ->with(['tasks', 'members'])
            ->when(request('search'), function ($query, $search) {
                $query->where('name', 'like', "%{$search}%");
            })
            ->when(request('status'), function ($query, $status) {
                $query->where('status', $status);
            })
            ->latest()
            ->get();
    }
    
    private function calculateProjectStats(Collection $projects): array
    {
        return [
            'total' => $projects->count(),
            'active' => $projects->where('status', 'active')->count(),
            'completed' => $projects->where('status', 'completed')->count(),
            'total_budget' => $projects->sum('budget'),
        ];
    }
    
    private function notifyTeamMembers(Project $project, string $action): void
    {
        $project->members->each(function ($member) use ($project, $action) {
            $member->notify(new ProjectNotification($project, $action));
        });
    }
}
```

### Private Methods Don'ts
```php
// ❌ Don't make them too complex
private function handleEverything($request)
{
    // 100 lines of code doing multiple things
}

// ❌ Don't expose as public
public function getUserProjects() // Should be private
{
    return auth()->user()->projects;
}

// ❌ Don't use unclear names
private function process($data) // What does it process?
private function handle($item) // Handle what?

// ❌ Don't test private methods directly
public function testPrivateMethod()
{
    $controller = new ProjectController();
    $method = new ReflectionMethod($controller, 'privateMethod');
    $method->setAccessible(true); // Don't do this
}
```

## Testing Controllers

### Controller Testing Do's
- **Test HTTP responses** - Status codes
- **Test authorization** - Access control
- **Test validation** - Error cases
- **Test redirects** - Correct routes
- **Use factories** - Realistic data

```php
// ✅ Testing resource controller
class ProjectControllerTest extends TestCase
{
    public function test_index_displays_projects()
    {
        $user = User::factory()->create();
        $projects = Project::factory()->count(3)->create(['user_id' => $user->id]);
        
        $response = $this->actingAs($user)->get('/projects');
        
        $response->assertOk();
        $response->assertInertia(fn (Assert $page) => $page
            ->component('Projects/Index')
            ->has('projects.data', 3)
        );
    }
    
    public function test_store_creates_project()
    {
        $user = User::factory()->create();
        
        $response = $this->actingAs($user)->post('/projects', [
            'name' => 'Test Project',
            'description' => 'Test Description',
        ]);
        
        $response->assertRedirect();
        $this->assertDatabaseHas('projects', [
            'name' => 'Test Project',
            'user_id' => $user->id,
        ]);
    }
    
    public function test_unauthorized_access_denied()
    {
        $user = User::factory()->create();
        $project = Project::factory()->create(); // Different owner
        
        $response = $this->actingAs($user)->get("/projects/{$project->id}/edit");
        
        $response->assertForbidden();
    }
}
```

## Common Pitfalls to Avoid

1. **Inline validation** - Always use FormRequests
2. **Fat controllers** - Extract to services
3. **Missing authorization** - Check permissions
4. **Wrong response types** - Response vs Redirect
5. **Direct model access** - Use DTOs
6. **No error handling** - Add try-catch blocks
7. **Missing type hints** - Specify return types
8. **Raw queries** - Use Eloquent/Query Builder
9. **No flash messages** - Provide user feedback
10. **Mixed responsibilities** - Keep controllers focused