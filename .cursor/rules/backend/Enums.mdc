---
description: PHP Enum patterns and best practices - comprehensive rules for Laravel applications
globs: ["**/app/Enums/**/*.php", "**/app/**/*.php"]
alwaysApply: true
---

# PHP Enum Development Rules and Best Practices

## Core Principles

### Do's
- **Use PHP 8.1+ native enums** - Built-in type safety
- **Prefer string-backed enums** - Better for databases and APIs
- **Use PascalCase for enum names** - Consistent with PHP conventions
- **Use UPPER_SNAKE_CASE for cases** - Clear visual distinction
- **Group related constants** - Better organization

### Don'ts
- **Don't use class constants** - Use proper enums instead
- **Avoid integer-backed enums** - Unless specifically needed
- **Don't use enums for dynamic values** - Enums are for fixed sets
- **Never store non-scalar values** - Enums are for simple values
- **Don't extend enums** - PHP enums are final by design

## Basic Enum Structure

### Basic Enum Do's
- **Define clear, descriptive names** - Self-documenting code
- **Use backed enums** - Specify string or int backing
- **Add helpful methods** - For common operations
- **Document enum purpose** - PHPDoc comments
- **Keep cases logically ordered** - Improve readability

```php
// ✅ Well-structured string-backed enum
<?php

namespace App\Enums;

enum UserRole: string
{
    case SUPER_ADMIN = 'super_admin';
    case ADMIN = 'admin';
    case MANAGER = 'manager';
    case USER = 'user';
    case GUEST = 'guest';
    
    public function label(): string
    {
        return match($this) {
            self::SUPER_ADMIN => 'Super Administrator',
            self::ADMIN => 'Administrator',
            self::MANAGER => 'Manager',
            self::USER => 'User',
            self::GUEST => 'Guest',
        };
    }
    
    public function color(): string
    {
        return match($this) {
            self::SUPER_ADMIN => 'red',
            self::ADMIN => 'orange',
            self::MANAGER => 'yellow',
            self::USER => 'blue',
            self::GUEST => 'gray',
        };
    }
    
    public function hasPermission(string $permission): bool
    {
        return match($this) {
            self::SUPER_ADMIN => true,
            self::ADMIN => in_array($permission, ['manage_users', 'manage_content']),
            self::MANAGER => in_array($permission, ['manage_content']),
            self::USER => in_array($permission, ['view_content']),
            self::GUEST => false,
        };
    }
}

// ✅ Status enum with logical ordering
enum OrderStatus: string
{
    case PENDING = 'pending';
    case PROCESSING = 'processing';
    case SHIPPED = 'shipped';
    case DELIVERED = 'delivered';
    case CANCELLED = 'cancelled';
    case REFUNDED = 'refunded';
    
    public function canTransitionTo(self $newStatus): bool
    {
        return match($this) {
            self::PENDING => in_array($newStatus, [self::PROCESSING, self::CANCELLED]),
            self::PROCESSING => in_array($newStatus, [self::SHIPPED, self::CANCELLED]),
            self::SHIPPED => in_array($newStatus, [self::DELIVERED]),
            self::DELIVERED => in_array($newStatus, [self::REFUNDED]),
            self::CANCELLED => false,
            self::REFUNDED => false,
        };
    }
}

// ✅ Simple enum without backing value
enum HttpMethod
{
    case GET;
    case POST;
    case PUT;
    case PATCH;
    case DELETE;
    
    public function isReadOnly(): bool
    {
        return $this === self::GET;
    }
}
```

### Basic Enum Don'ts
```php
// ❌ Don't use class constants instead of enums
class UserRole
{
    const ADMIN = 'admin';
    const USER = 'user';
}

// ❌ Don't use integer backing without good reason
enum Status: int
{
    case ACTIVE = 1;    // Harder to debug
    case INACTIVE = 0;  // Less readable in database
}

// ❌ Don't use inconsistent naming
enum badNaming: string
{
    case Active = 'active';      // Should be ACTIVE
    case inactive = 'inactive';  // Inconsistent case
    case IS_DELETED = 'deleted'; // Inconsistent prefix
}

// ❌ Don't create enums for dynamic values
enum ProductPrice: float // Prices change, don't use enum
{
    case BASIC = 9.99;
    case PREMIUM = 19.99;
}

// ❌ Don't forget backing type when needed
enum Status // Missing : string
{
    case ACTIVE = 'active'; // Will cause error
}
```

## Enum Methods and Features

### Enum Methods Do's
- **Add value getters** - For common transformations
- **Create validation methods** - Check state transitions
- **Use match expressions** - Exhaustive checking
- **Add comparison methods** - For business logic
- **Create factory methods** - For common conversions

```php
// ✅ Enum with comprehensive methods
enum PaymentStatus: string
{
    case PENDING = 'pending';
    case AUTHORIZED = 'authorized';
    case CAPTURED = 'captured';
    case FAILED = 'failed';
    case REFUNDED = 'refunded';
    case VOIDED = 'voided';
    
    public function isPending(): bool
    {
        return $this === self::PENDING;
    }
    
    public function isSuccessful(): bool
    {
        return in_array($this, [self::AUTHORIZED, self::CAPTURED]);
    }
    
    public function isFinal(): bool
    {
        return in_array($this, [self::CAPTURED, self::FAILED, self::REFUNDED, self::VOIDED]);
    }
    
    public function canBeRefunded(): bool
    {
        return $this === self::CAPTURED;
    }
    
    public function icon(): string
    {
        return match($this) {
            self::PENDING => 'clock',
            self::AUTHORIZED => 'shield-check',
            self::CAPTURED => 'check-circle',
            self::FAILED => 'x-circle',
            self::REFUNDED => 'arrow-left-circle',
            self::VOIDED => 'ban',
        };
    }
    
    public function description(): string
    {
        return match($this) {
            self::PENDING => 'Payment is being processed',
            self::AUTHORIZED => 'Payment authorized but not captured',
            self::CAPTURED => 'Payment successfully captured',
            self::FAILED => 'Payment failed to process',
            self::REFUNDED => 'Payment has been refunded',
            self::VOIDED => 'Payment authorization voided',
        };
    }
    
    public static function fromGatewayStatus(string $gatewayStatus): self
    {
        return match($gatewayStatus) {
            'stripe_pending', 'paypal_pending' => self::PENDING,
            'stripe_authorized' => self::AUTHORIZED,
            'stripe_succeeded', 'paypal_completed' => self::CAPTURED,
            'stripe_failed', 'paypal_failed' => self::FAILED,
            default => throw new \InvalidArgumentException("Unknown gateway status: {$gatewayStatus}"),
        };
    }
}

// ✅ Enum with static helpers
enum Priority: string
{
    case CRITICAL = 'critical';
    case HIGH = 'high';
    case MEDIUM = 'medium';
    case LOW = 'low';
    
    public function weight(): int
    {
        return match($this) {
            self::CRITICAL => 100,
            self::HIGH => 75,
            self::MEDIUM => 50,
            self::LOW => 25,
        };
    }
    
    public static function fromWeight(int $weight): self
    {
        return match(true) {
            $weight >= 90 => self::CRITICAL,
            $weight >= 70 => self::HIGH,
            $weight >= 40 => self::MEDIUM,
            default => self::LOW,
        };
    }
    
    public static function options(): array
    {
        return array_map(
            fn(self $priority) => [
                'value' => $priority->value,
                'label' => $priority->label(),
                'color' => $priority->color(),
            ],
            self::cases()
        );
    }
}
```

### Enum Methods Don'ts
```php
// ❌ Don't use if/else instead of match
public function label(): string
{
    if ($this === self::ACTIVE) {
        return 'Active';
    } elseif ($this === self::INACTIVE) {
        return 'Inactive';
    }
    // Missing cases! Use match for exhaustiveness
}

// ❌ Don't return arrays from enum methods
public function getData(): array // Too generic
{
    return ['some' => 'data'];
}

// ❌ Don't add mutable state
class BadEnum
{
    private string $customLabel; // Enums are immutable!
    
    public function setLabel(string $label): void
    {
        $this->customLabel = $label;
    }
}

// ❌ Don't use dynamic method names
public function __call($method, $args) // No magic methods
{
    // Dynamic behavior defeats enum purpose
}
```

## Laravel Integration

### Laravel Integration Do's
- **Use in Eloquent casts** - Automatic conversion
- **Create validation rules** - Type-safe validation
- **Use in migrations** - Define column constraints
- **Integrate with forms** - Dropdown options
- **Use in API resources** - Consistent formatting

```php
// ✅ Eloquent model integration
use App\Enums\UserRole;
use App\Enums\AccountStatus;

class User extends Model
{
    protected $casts = [
        'role' => UserRole::class,
        'status' => AccountStatus::class,
        'preferences' => 'json',
    ];
    
    public function isAdmin(): bool
    {
        return $this->role === UserRole::ADMIN 
            || $this->role === UserRole::SUPER_ADMIN;
    }
    
    public function canManageUsers(): bool
    {
        return $this->role->hasPermission('manage_users');
    }
    
    // Scope for enum filtering
    public function scopeWithRole(Builder $query, UserRole $role): Builder
    {
        return $query->where('role', $role);
    }
    
    public function scopeActive(Builder $query): Builder
    {
        return $query->where('status', AccountStatus::ACTIVE);
    }
}

// ✅ Migration with enum constraint
Schema::create('users', function (Blueprint $table) {
    $table->id();
    $table->string('name');
    $table->enum('role', array_column(UserRole::cases(), 'value'))
          ->default(UserRole::USER->value);
    $table->enum('status', array_column(AccountStatus::cases(), 'value'))
          ->default(AccountStatus::PENDING->value);
});

// ✅ Validation rule
use Illuminate\Validation\Rules\Enum;

class UpdateUserRequest extends FormRequest
{
    public function rules(): array
    {
        return [
            'name' => ['required', 'string'],
            'role' => ['required', new Enum(UserRole::class)],
            'status' => ['required', new Enum(AccountStatus::class)],
        ];
    }
}

// ✅ API Resource
class UserResource extends JsonResource
{
    public function toArray($request): array
    {
        return [
            'id' => $this->id,
            'name' => $this->name,
            'role' => [
                'value' => $this->role->value,
                'label' => $this->role->label(),
                'color' => $this->role->color(),
            ],
            'status' => [
                'value' => $this->status->value,
                'label' => $this->status->label(),
            ],
        ];
    }
}

// ✅ Form options helper
class EnumOptions
{
    public static function forSelect(string $enumClass): array
    {
        return collect($enumClass::cases())
            ->map(fn($case) => [
                'value' => $case->value,
                'label' => method_exists($case, 'label') 
                    ? $case->label() 
                    : str($case->name)->title()->replace('_', ' '),
            ])
            ->toArray();
    }
}
```

### Laravel Integration Don'ts
```php
// ❌ Don't forget to cast in model
class User extends Model
{
    // Missing casts
    // Role will be string, not enum instance
}

// ❌ Don't use string validation for enums
'role' => ['required', 'string', 'in:admin,user'] // Use Enum rule

// ❌ Don't hardcode enum values
if ($user->role === 'admin') { // Use enum constant
    // ...
}

// ❌ Don't forget default values in migrations
$table->enum('status'); // Add default

// ❌ Don't return raw enum in API
return [
    'status' => $this->status, // Returns enum instance, not JSON-safe
];
```

## Advanced Enum Patterns

### Advanced Patterns Do's
- **Create trait for common functionality** - DRY principle
- **Use interfaces for contracts** - Ensure consistency
- **Add static analysis helpers** - Better IDE support
- **Create enum collections** - For bulk operations
- **Use with value objects** - Rich domain models

```php
// ✅ Enum trait for common functionality
trait EnumHelpers
{
    public static function values(): array
    {
        return array_column(self::cases(), 'value');
    }
    
    public static function names(): array
    {
        return array_column(self::cases(), 'name');
    }
    
    public static function toArray(): array
    {
        return array_combine(self::names(), self::values());
    }
    
    public static function tryFromName(string $name): ?self
    {
        foreach (self::cases() as $case) {
            if ($case->name === $name) {
                return $case;
            }
        }
        return null;
    }
    
    public static function random(): self
    {
        return self::cases()[array_rand(self::cases())];
    }
}

// ✅ Interface for labellable enums
interface LabelledEnum
{
    public function label(): string;
    public function color(): string;
}

enum TaskPriority: string implements LabelledEnum
{
    use EnumHelpers;
    
    case URGENT = 'urgent';
    case HIGH = 'high';
    case NORMAL = 'normal';
    case LOW = 'low';
    
    public function label(): string
    {
        return match($this) {
            self::URGENT => 'Urgent',
            self::HIGH => 'High Priority',
            self::NORMAL => 'Normal',
            self::LOW => 'Low Priority',
        };
    }
    
    public function color(): string
    {
        return match($this) {
            self::URGENT => '#dc2626',
            self::HIGH => '#f59e0b',
            self::NORMAL => '#3b82f6',
            self::LOW => '#6b7280',
        };
    }
}

// ✅ Enum with complex business logic
enum SubscriptionPlan: string
{
    case FREE = 'free';
    case BASIC = 'basic';
    case PRO = 'pro';
    case ENTERPRISE = 'enterprise';
    
    public function features(): array
    {
        return match($this) {
            self::FREE => ['basic_access'],
            self::BASIC => ['basic_access', 'email_support', 'api_access'],
            self::PRO => ['basic_access', 'email_support', 'api_access', 'priority_support', 'advanced_features'],
            self::ENTERPRISE => ['all_features', 'dedicated_support', 'sla', 'custom_integration'],
        };
    }
    
    public function hasFeature(string $feature): bool
    {
        return in_array($feature, $this->features());
    }
    
    public function monthlyPrice(): float
    {
        return match($this) {
            self::FREE => 0.0,
            self::BASIC => 9.99,
            self::PRO => 29.99,
            self::ENTERPRISE => 99.99,
        };
    }
    
    public function canUpgradeTo(self $plan): bool
    {
        $hierarchy = [
            self::FREE->value => 0,
            self::BASIC->value => 1,
            self::PRO->value => 2,
            self::ENTERPRISE->value => 3,
        ];
        
        return $hierarchy[$plan->value] > $hierarchy[$this->value];
    }
}

// ✅ Using enums with value objects
readonly class Money
{
    public function __construct(
        public float $amount,
        public Currency $currency,
    ) {}
    
    public function format(): string
    {
        return $this->currency->format($this->amount);
    }
}

enum Currency: string
{
    case USD = 'USD';
    case EUR = 'EUR';
    case GBP = 'GBP';
    
    public function symbol(): string
    {
        return match($this) {
            self::USD => '$',
            self::EUR => '€',
            self::GBP => '£',
        };
    }
    
    public function format(float $amount): string
    {
        return match($this) {
            self::USD => '$' . number_format($amount, 2),
            self::EUR => '€' . number_format($amount, 2, ',', '.'),
            self::GBP => '£' . number_format($amount, 2),
        };
    }
}
```

### Advanced Patterns Don'ts
```php
// ❌ Don't over-engineer simple enums
enum SimpleStatus: string
{
    case ACTIVE = 'active';
    case INACTIVE = 'inactive';
    
    // Too many unnecessary methods for simple enum
    public function toJson() { }
    public function toXml() { }
    public function toYaml() { }
}

// ❌ Don't use inheritance (not possible anyway)
enum Child extends Parent { } // PHP Error

// ❌ Don't store complex objects
enum BadEnum: string
{
    case USER = 'user';
    
    private User $userModel; // Can't store objects
}

// ❌ Don't use enums for configuration
enum Config: string
{
    case API_KEY = 'secret123'; // Use config files
    case DB_HOST = 'localhost'; // Not for configuration
}
```

## Testing Enums

### Testing Do's
- **Test enum methods** - Ensure correct behavior
- **Test all match arms** - Cover all cases
- **Test invalid inputs** - Handle errors gracefully
- **Test Laravel integration** - Model casts, validation

```php
// ✅ Testing enum methods
class UserRoleTest extends TestCase
{
    public function test_role_labels_are_correct()
    {
        $this->assertEquals('Administrator', UserRole::ADMIN->label());
        $this->assertEquals('User', UserRole::USER->label());
    }
    
    public function test_permission_checking()
    {
        $this->assertTrue(UserRole::ADMIN->hasPermission('manage_users'));
        $this->assertFalse(UserRole::USER->hasPermission('manage_users'));
    }
    
    public function test_all_roles_have_labels()
    {
        foreach (UserRole::cases() as $role) {
            $this->assertNotEmpty($role->label());
        }
    }
}

// ✅ Testing enum validation
public function test_validates_enum_values()
{
    $this->post('/users', [
        'name' => 'John Doe',
        'role' => 'invalid_role',
    ])->assertSessionHasErrors(['role']);
    
    $this->post('/users', [
        'name' => 'John Doe',
        'role' => UserRole::ADMIN->value,
    ])->assertSessionDoesntHaveErrors(['role']);
}

// ✅ Testing model integration
public function test_model_casts_enum_correctly()
{
    $user = User::create([
        'name' => 'Test User',
        'role' => UserRole::ADMIN->value,
    ]);
    
    $this->assertInstanceOf(UserRole::class, $user->role);
    $this->assertTrue($user->role === UserRole::ADMIN);
}
```

## Frontend Integration

### Frontend Integration Do's
- **Export enum values** - Make available to frontend
- **Keep in sync** - Frontend/backend consistency
- **Use TypeScript enums** - Type safety in Vue/React
- **Document API format** - Clear expectations

```php
// ✅ Controller providing enum options
class EnumController extends Controller
{
    public function userRoles()
    {
        return response()->json([
            'roles' => collect(UserRole::cases())->map(fn($role) => [
                'value' => $role->value,
                'label' => $role->label(),
                'color' => $role->color(),
                'permissions' => $role->permissions(),
            ]),
        ]);
    }
}

// ✅ Inertia shared data
HandleInertiaRequests::class

public function share(Request $request): array
{
    return array_merge(parent::share($request), [
        'enums' => [
            'userRoles' => EnumOptions::forSelect(UserRole::class),
            'orderStatuses' => EnumOptions::forSelect(OrderStatus::class),
        ],
    ]);
}

// ✅ TypeScript definition (in frontend)
export enum UserRole {
  SUPER_ADMIN = 'super_admin',
  ADMIN = 'admin',
  USER = 'user',
}

export interface EnumOption {
  value: string
  label: string
  color?: string
}
```

## Common Pitfalls to Avoid

1. **Using class constants** - Use proper enums instead
2. **Integer backing without reason** - Prefer strings
3. **Inconsistent naming** - Follow conventions
4. **Missing enum casting** - Add to Eloquent models
5. **Hardcoding values** - Use enum constants
6. **No validation** - Use Laravel's Enum rule
7. **Complex logic in enums** - Keep simple
8. **Dynamic values** - Enums are for fixed sets
9. **Missing labels** - Add user-friendly names
10. **No default in migrations** - Always set defaults